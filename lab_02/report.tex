

\documentclass[12pt]{report}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage[14pt]{extsizes}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{amsmath,amsfonts,amssymb,amsthm,mathtools} 
\usepackage{pgfplots}
\usepackage{filecontents}
\usepackage{float}
\usepackage{indentfirst}
\usepackage{eucal}
\usepackage{enumitem}
%s\documentclass[openany]{book}
\frenchspacing

\usepackage{titlesec}
\titleformat{\section}
{\normalsize\bfseries}
{\thesection}
{1em}{}
\titlespacing*{\chapter}{0pt}{-30pt}{8pt}
\titlespacing*{\section}{\parindent}{*4}{*4}
\titlespacing*{\subsection}{\parindent}{*4}{*4}

\usepackage{indentfirst} % Красная строка

\usetikzlibrary{datavisualization}
\usetikzlibrary{datavisualization.formats.functions}

\usepackage{amsmath}


% Для листинга кода:
\lstset{ %
	language=c,                 % выбор языка для подсветки (здесь это С)
	basicstyle=\small\sffamily, % размер и начертание шрифта для подсветки кода
	numbers=left,               % где поставить нумерацию строк (слева\справа)
	numberstyle=\tiny,           % размер шрифта для номеров строк
	stepnumber=1,                   % размер шага между двумя номерами строк
	numbersep=5pt,                % как далеко отстоят номера строк от подсвечиваемого кода
	showspaces=false,            % показывать или нет пробелы специальными отступами
	showstringspaces=false,      % показывать или нет пробелы в строках
	showtabs=false,             % показывать или нет табуляцию в строках
	frame=single,              % рисовать рамку вокруг кода
	tabsize=2,                 % размер табуляции по умолчанию равен 2 пробелам
	captionpos=t,              % позиция заголовка вверху [t] или внизу [b] 
	breaklines=true,           % автоматически переносить строки (да\нет)
	breakatwhitespace=false, % переносить строки только если есть пробел
	escapeinside={\#*}{*)}   % если нужно добавить комментарии в коде
}


\usepackage[left=2cm,right=2cm, top=2cm,bottom=2cm,bindingoffset=0cm]{geometry}
% Для измененных титулов глав:
\usepackage{titlesec, blindtext, color} % подключаем нужные пакеты
\definecolor{gray75}{gray}{0.75} % определяем цвет
\newcommand{\hsp}{\hspace{20pt}} % длина линии в 20pt
% titleformat определяет стиль
\titleformat{\chapter}[hang]{\Huge\bfseries}{\thechapter\hsp\textcolor{gray75}{|}\hsp}{0pt}{\Huge\bfseries}


% plot
\usepackage{pgfplots}
\usepackage{filecontents}
\usetikzlibrary{datavisualization}
\usetikzlibrary{datavisualization.formats.functions}

\begin{document}
	%\def\chaptername{} % убирает "Глава"
	\thispagestyle{empty}
	\begin{titlepage}
		\noindent \begin{minipage}{0.15\textwidth}
			\includegraphics[width=\linewidth]{img/b_logo}
		\end{minipage}
		\noindent\begin{minipage}{0.9\textwidth}\centering
			\textbf{Министерство науки и высшего образования Российской Федерации}\\
			\textbf{Федеральное государственное бюджетное образовательное учреждение высшего образования}\\
			\textbf{~~~«Московский государственный технический университет имени Н.Э.~Баумана}\\
			\textbf{(национальный исследовательский университет)»}\\
			\textbf{(МГТУ им. Н.Э.~Баумана)}
		\end{minipage}
		
		\noindent\rule{18cm}{3pt}
		\newline\newline
		\noindent ФАКУЛЬТЕТ $\underline{\text{«Информатика и системы управления»}}$ \newline\newline
		\noindent КАФЕДРА $\underline{\text{«Программное обеспечение ЭВМ и информационные технологии»}}$\newline\newline\newline\newline\newline
		
		\begin{center}
			\noindent\begin{minipage}{1.1\textwidth}\centering
				\Large\textbf{  Отчет по лабораторной работе №2}\newline
				\textbf{по дисциплине <<Функциональное и логическое}\newline
				\textbf{~~~программирование>>}\newline\newline
			\end{minipage}
		\end{center}
		
		\noindent\textbf{Тема} $\underline{\text{Определение функций пользователя}}$\newline\newline
		\noindent\textbf{Студент} $\underline{\text{Зайцева А. А.~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}}$\newline\newline
		\noindent\textbf{Группа} $\underline{\text{ИУ7-62Б~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}}$\newline\newline
		\noindent\textbf{Оценка (баллы)} $\underline{\text{~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}}$\newline\newline
		\noindent\textbf{Преподаватели} $\underline{\text{Толпинская Н.Б., Строганов Ю. В.~~~~~~~~~~~~~~~~~~~~~~~~~~~~}}$\newline\newline\newline
		
		\begin{center}
			\vfill
			Москва~---~\the\year
			~г.
		\end{center}
	\end{titlepage}
	
\chapter*{Теоретические вопросы}

\section*{1. Базис Lisp}
	
Базис -- это минимальный набор инструментов языка и стркутур данных, который позволяет решить любые задачи.


Базис Lisp :

\begin{itemize}
	\item атомы (представляются в памяти пятью указателями  --  name, value, function, property, package) и структуры (представляющиеся бинарными узлами);
	\item базовые (несколько) функций, функционалов и форм: встроенные — примитивные функции (atom, eq, cons, car, cdr); формы (quote, cond, lambda, eval); функционалы (apply, funcall).
\end{itemize}

Атомы:
\begin{itemize} 
	\item символы (идентификаторы) – синтаксически – набор литер (букв и цифр), начинающихся с буквы;
	\item специальные символы – {T, Nil} (используются для обозначения логических констант);
	\item самоопределимые атомы – натуральные числа, дробные числа, вещественные числа, строки – последовательность символов, заключенных в двойные апострофы (например, “abc”);
\end{itemize} 

Более сложные данные – списки и точечные пары (структуры), которые строятся с помощью унифицированных структур – блоков памяти – бинарных узлов.

Определения:

Точечная пара ::= (<атом> . <атом>) | (<атом> . <точечная пара>) | (<точечная пара> . <атом>) | (<точечная пара> . <точечная пара>);

Список ::= <пустой список> | <непустой список>, где 

<пустой список> ::= () | Nil,

<непустой список> ::= (<первый элемент> . <хвост>),

<первый элемент> ::= <S-выражение>,

S-выражение ::= <атом> | <точечная пара>,

<хвост> ::= <список>.


Функцией называется правило, по которому каждому значению одного или нескольких  аргументов ставится в соответствие конкретное значение результата. 

%Функции всюду определены (то есть результат есть всегда), их аргументы и результаты -- S-выражения.

Функционалом, или функцией высшего порядка называется функция, аргументом или  результатом которой является другая функция.

Форма -- функция, которая особым образом обрабатывает свои аргументы, т. е. требует специальной обработки.

%Форма, или вычислимое выражение – это атом или список, который можно  вычислить и получить значение.



\section*{2.Классификация функций}


\begin{enumerate}
	\item Чистые  математические функции (имеют фиксированное количество аргументов, сначала выяисляются все аргументы, а только потом к ним применяется функция);
	\item Рекурсивные функции (основной способ выполнения повторных вычислений);
	\item Специальные функции, или формы (могут принимать произвольное количество аргументов, или аргументы могут обрабатываться по-разному);
	\item Псевдофункции (создают «эффект», например, вывод на экран);
	\item Функции с вариантами значений, из которых выбирается одно;
	\item Функции высших порядков, или функционалы --  функции, аргументом или  результатом которых является другая функция (используются для построения синтаксически управляемых программ);
\end{enumerate}

Классификаци базисных функций и функций ядра.

\begin{enumerate}
	\item Селекторы: car и cdr (будут подробнее расссмотрены ниже).
	\item Конструкторы: cons и list (будут подробнее расссмотрены ниже).
	\item Предикаты -- <<логические>> функции, позволяющие определить структуру элемента:
	\begin{itemize}
		\item atom возвращает T, если значением её единственного аргумента является атом, иначе -- NIL;
		\item null возвращает T, если значение его аргумента -- NIL (пустой список), иначе -- NIL;
		\item listp возвращает T, если значением её аргумента является список, иначе -- NIL;
		\item consp возвращает T, если значением её аргумента является структура, представленная в виде списковой ячейки, иначе -- NIL. 
	\end{itemize}
	\item Функции сравнения (принимают два аргумента, перечислены по мере роста <<тщательности>> проверки):
	\begin{itemize}
		\item eq корректно сравнивает два символьных атома. Так как атомы не дублирутюся для данного сеанса работы, то фактически сравниваются соответсвующие указатели. 
		Возвращает T, когда: 1) значением одного из аргументов является атом, и одновременно 2) значения аргументов равны (идентичны). В ином случае значением функции eq является NIL. (eq  'ab 'Ab) => T, но (eq 1 2) => NIL.
		\item eql корректно сравнивает атомы и числа одинакового типа (синтетической формы записи). Например, (eql 1 1) вернет T, а (eql 1 1.0) -- Nil, так как целое значение 1 и значение с плавающей точкой 1.0 являются представителями различных классов;
		\item = корректно сравнивает только числа, причем числа могут быть разных типов. Например, и (= 1 1), и (= 1 1.0) вернет T;
		\item equal работает идентично eql, но в дополнение умеет корректно сравнивать списки (считая списки эквивалентными, если они рекурсивно, согласно тому же equal, имеют одинаковую структуру и содержимое; считая строки эквивалентными, если они содержат одинаковые знаки);
		\item equalp корректно сравнивает любые S-выражения. 
	\end{itemize}
\end{enumerate}
	


\section*{3. Способы создания функций}

Определение функций пользователя в Lisp-е возможно двумя способами.


\begin{itemize}
	\item Базисный способ  определения  функции - использование $\lambda$-выражения ($\lambda$-нотации). Так создаются функции без имени.
	
	$\lambda$-выражение: (lambda $\lambda$-список форма), 
	где $\lambda$-список --  это формальные параметры функции (список аргументов), а форма -- это тело функции.
	
	Вызов такой функции осуществляется следующим способом: ($\lambda$-выражение последовательность\_форм), 
	где последовательность\_форм -- это список фактических параметров.
	
	Вычисление функций без имени может быть выполнено с использованием функционала apply: (apply $\lambda$-выражение последовательность\_форм), где последовательность\_форм -- это список фактических параметров, или с использованием функционала funcall: (funcall $\lambda$-выражение последовательность\_форм), где последовательность\_форм -- это фактические параметры.
	
	Функционал apply является обычной функцией с двумя  вычисляемыми аргументами, обращение к ней имеет вид: (apply F L), где F – функциональный аргумент и L -- список, рассматриваемый как список фактических параметров для F. Значение функционала -- результат применения F к этим фактическим параметрам.
	
	Функционал funcall – особая функция с вычисляемыми аргументами, обращение к ней: (funcall F e1 … en), n $\geqslant 0$. Её   действие аналогично apply, отличие состоит в том, что аргументы  применяемой функции F задаются не списком, а по отдельности. 
	
	\item Другой способ определения функции -- использование макро-определения defun: 
	
	(defun имя\_функции $\lambda$-выражение), 
	
	или  в облегченной форме:
	
	(defun имя\_функции $(x_1, x_2, ..., x_k)$ (форма)), 
	где $(x_1, x_2, ..., x_k)$ -- это  список аргументов.
	
	В качестве имени функции выступает символьный атом. 
	Вызов именованной функции осуществляется следующим образом: (имя\_функции последовательность\_форм), 
	где последовательность\_форм -- это фактические параметры
	
\end{itemize}

$\lambda$-определение более эффективно, особенно при повторных вычислениях. 

Параметры функции, переданные при вызове, будут связаны с переменными в списке параметров из объявления функции. Еще один способ связывания формальных параметров с фактическими -- использование функции let:

(let ((x1 p1) (x2 p2) ... (xk pk))  e),

где xi -- формальные параметры, pi -- фактические параметры (могут быть формами), e -- форма (что делать).

\section*{4. Функции Car и Cdr}

Функции car и cdr переходят по соответсвующему указателю аргумента (бинарного узла).

Функция car от одного аргумента возвращает первый элемент списка, являющегося значением её аргумента. 

Функция cdr возвращает хвост списка, являющегося значением её единственного аргумента (хвостом, или остатком списка является список  без своего первого элемента).  

Современные диалекты  Лиспа обычно допускают для функций car и cdr мнемоничные синонимичные названия: first и rest соответственно.

\section*{5. Назначение и отличие в работе Cons и List}

CONS принимает 2 указателя на любые S-выражения и возвращает новую cons-ячейку (списковую ячейку), содержащую 2 значения. Если второе значение не NIL и не другая cons-ячейка, то ячейка печатается как два значения в скобках, разделённые точкой (так называемая точечная пара). Иначе, по сути, эта функция включает значение первого аргумента в начало списка, являющегося значением второго аргумента. 

Функция list, составляющая список из значений своих аргументов (у которого голова -- это первый аргумент, хвост -- все остальные аргументы), создает столько списковых ячеек, сколько аргументов ей было передано. Эта функция относится к особым, поскольку у неё может быть произвольное число аргументов, но при этом все аргументы вычисляются

Итак, отличия: cons является базисной, list -- нет; cons имеет  фиксированное количество аргументов (два), list -- произвольное; cons создает точечную пару или список (в зависимости от второго аргумента), list -- список; в отличие от функции cons, результат функции list симметричен относительно аргументов: (list '(А) '(В)) => ((А)(В)), но (cons '(А) '(В)) => ((А) В).

Cons эффективнее list, list определяется с помощью cons.

 

\section*{Из указаний  к выполнению работы}

Eval выполняет двойное  вычисление своего аргумента. Эта функция является обычной, и первое  вычисление аргумента выполняет так же, как и любая обычная функция.  Полученное при этом выражение вычисляется ещё раз. Такое двойное  вычисление может понадобиться либо для снятия блокировки вычислений (установленной функцией quote), либо же для вычисления сформированного в ходе первого вычисления нового функционального вызова.

\clearpage
Вызов (eval S-выражение):

\includegraphics[scale=0.5]{img/eval}



Квотирование объекта -- это применение к нему функции quote, которая в качестве своего значения выдаёт сам аргумент, не вычисляя его. По сути, эта функция блокирует вычисление своего аргумента. Необходимость в этом нередко возникает при использовании обычных встроенных функций, чтобы задать аргументы в явном виде и избежать их вычисления. Константы–числа и атомы T, NIL при их  использовании в качестве аргументов обычных функций можно не  квотировать, поскольку значением любой константы является она сама. Функция quote используется часто, поэтому допускается упрощённый способ обращения к ней с помощью апострофа, маркирующего квотируемое выражение.


В диалекте Common Lisp для замыкания функционального аргумента встроена специальная форма (function F), где F – определяющее  выражение функции. Эту форму часто называют функциональной  блокировкой, поскольку она аналогична по действию функции quote, но  не просто квотирует аргумент, а как бы замыкает значения используемых  в функциональном аргументе F свободных переменных, фиксируя их значения из контекста его определения. Функциональную блокировку  можно записывать короче, с помощью двух знаков \#' (получить функцию с данным именем").






	
\chapter*{Практические задания}	

\section*{1. Составить диаграмму вычисления следующих выражений:
}

1. (equal 3 (abs - 3))

\includegraphics[scale=1]{img/1.1}

2. (equal (+ 1 2) 3)

\includegraphics[scale=1]{img/1.2}


3. (equal (* 4 7) 21)

\includegraphics[scale=1]{img/1.3}


\clearpage
4. (equal (* 2 3) (+ 7 2))

\includegraphics[scale=1]{img/1.4}


5. (equal (- 7 3) (* 3 2))

\includegraphics[scale=1]{img/1.5}

\clearpage
6. (equal (abs (- 2 4)) 3)

\includegraphics[scale=1]{img/1.6}

\clearpage
\section*{2. Написать функцию, вычисляющую гипотенузу прямоугольного треугольника по заданным катетам, и составить диаграмму её вычисления.}

\begin{lstlisting}[language=Lisp]
	(defun hypotenuse (a b) (sqrt (+ (* a a) (* b  b))))
	(hypotenuse 3 4) => 5.0 
\end{lstlisting}

\includegraphics[scale=1]{img/2}

\clearpage
\section*{3. Написать функцию, вычисляющую объем параллелепипеда по 3-м его сторонам, и составить диаграмму ее вычисления.}

\begin{lstlisting}[language=Lisp]
	(defun p_volume (a b c) (* (* a b) c))
	(p_volume 2 3 4) => 24 
	;; or
	(defun p_volume (a b c) (* a b c))
	(p_volume 2 3 4) => 24 
\end{lstlisting}

\includegraphics[scale=1]{img/3}

\section*{4. Каковы результаты вычисления следующих выражений?(объяснить возможную ошибку и варианты ее устранения)}

\textbf{1.}
 
\begin{lstlisting}[language=Lisp]
(list 'a c) => The variable C is unbound.
\end{lstlisting}

Одна из возможных ошибок: переменная c не связана со значением. Решение: задать переменнной c некоторое значение.
\begin{lstlisting}[language=Lisp]
(let ((c 'c)) (list 'a c)) => (A C)
\end{lstlisting}

Другая из возможных ошибок: предполагалось, что с -- это символ. Решение: использовать функцию quote (или сокращенную -- апостроф) для блокировки вычисления аргумента.
\begin{lstlisting}[language=Lisp]
	(list 'a 'c) => (A C)
\end{lstlisting}




\clearpage
\textbf{2.}
\begin{lstlisting}[language=Lisp]
	 (cons 'a (b c)) => Undefined function: B, Undefined variable: C
\end{lstlisting}

Одна из возможных ошибок: функция b не связана со своим определением, а переменная c не связана со своимм значением. Решение: определить функцию b с одним аргументом (или переменным количеством аргументов), а переменной c задать некоторое значение.
\begin{lstlisting}[language=Lisp]
	(defun b (c) (cons 'b (cons c Nil)))
	(b 'c) => (B C)
	(let ((c 'c)) (cons 'a (b c))) => (A B C)
	
\end{lstlisting}

Другая из возможных ошибок: предполагалось, что (b c) -- это список из символов b и c. Решение: использовать функцию quote (или сокращенную -- апостроф) для блокировки вычисления аргументов.
\begin{lstlisting}[language=Lisp]
	(cons 'a '(b c)) => (A B C)
\end{lstlisting}






\textbf{3.} 
\begin{lstlisting}[language=Lisp]
	(cons 'a '(b c)) => (A B C)
\end{lstlisting}
Ошибок нет





\textbf{4.} 

\begin{lstlisting}[language=Lisp]
	(caddy (1 2 3 4 5))  => Undefined function: CADDY
\end{lstlisting}

Одна из возможных ошибок: функция caddy не связана со своим определением, а список (1 2 3 4 5) не квотирован. Решение: определить функцию caddy, принимающую один аргумент  (или переменное число аргуентов), и использовать функцию quote (или сокращенную -- апостроф) для блокировки вычисления аргумента.
\begin{lstlisting}[language=Lisp]
	(defun caddy (arg) arg)
	(caddy '(1 2 3 4 5)) => (1 2 3 4 5)
\end{lstlisting}

Другая из возможных ошибок: предполагалось вызвать функцию caddr для получения третьего элемента списка (1 2 3 4 5). Решение: исправить опечатку (заменить caddy на caddr) и использовать функцию quote (или сокращенную -- апостроф) для блокировки вычисления аргумента.
\begin{lstlisting}[language=Lisp]
	(caddr '(1 2 3 4 5)) => 3
\end{lstlisting}



\clearpage
\textbf{5.}

\begin{lstlisting}[language=Lisp]
	(cons 'a 'b 'c)  => The function CONS is called with three arguments, but wants exactly two.
\end{lstlisting}

Ошибка: функция cons вызвана с тремя аргументами, хотя она принимает два аргумента. Решение: предполагая, что автор хотел получить список из трех символов  (a b c), можно либо первым аргументом передать символ a, а вторым -- список (b c), либо использовать функцию list вместо cons.


\begin{lstlisting}[language=Lisp]
	(cons 'a '(b c)) => (A B C)
	(list 'a 'b 'c) => (A B C)
\end{lstlisting}




\textbf{6.} 
\begin{lstlisting}[language=Lisp]
	(list 'a (b c)) => Undefined function: B, Undefined variable: C
\end{lstlisting}

(Аналогично пункту 2)

Одна из возможных ошибок: функция b не связана со своим определением, а переменная c не связана со своимм значением. Решение: определить функцию b с одним аргументом (или переменным количеством аргументов), а переменной c задать некоторое значение.
\begin{lstlisting}[language=Lisp]
	(defun b (c) (cons 'b (cons c Nil)))
	(b 'c) => (B C)
	(let ((c 'c)) (list 'a (b c))) => (A (B C))
	
\end{lstlisting}

Другая из возможных ошибок: предполагалось, что (b c) -- это список из символов b и c. Решение: использовать функцию quote (или сокращенную -- апостроф) для блокировки вычисления аргументов.
\begin{lstlisting}[language=Lisp]
	(list 'a '(b c)) => (A (B C))
\end{lstlisting}







\textbf{7.} 
\begin{lstlisting}[language=Lisp]
	(list a '(b c)) => The variable A is unbound.
\end{lstlisting}

Одна из возможных ошибок: переменная a не связана со значением. Решение: задать переменнной a некоторое значение.
\begin{lstlisting}[language=Lisp]
	(let ((a 'a)) (list a '(b c))) => (A (B C))
\end{lstlisting}

Другая из возможных ошибок: предполагалось, что a -- это символ. Решение: использовать функцию quote (или сокращенную -- апостроф) для блокировки вычисления аргумента.
\begin{lstlisting}[language=Lisp]
	(list 'a '(b c)) => (A (B C))
\end{lstlisting}







\clearpage
\textbf{8.} 

\begin{lstlisting}[language=Lisp]
	(list (+ 1 '(length '(1 2 3)))) =>   Value of '(LENGTH '(1 2 3)) in (+ 1 '(LENGTH '(1 2 3))) is (LENGTH '(1 2 3)), not a NUMBER.
\end{lstlisting}

Функция + в качестве аргументов ожидает аргументы типа NUMBER. Вторымм аргументом ей передано '(length '(1 2 3)). Функция length возвращает длину переданного ей списка (тип NUMBER), однако апостроф блокирует вычисление. Таким образом, вместо длины списка типа NUMBER функции + в качестве второго аргумента передается значение (LENGTH '(1 2 3)). Решение - убрать апостроф, блокирующий вычисления аргумента.

\begin{lstlisting}[language=Lisp]
	(list (+ 1 (length '(1 2 3)))) => (4)
\end{lstlisting}






\section*{5. Написать функцию longer\_then от двух списков-аргументов, которая возвращает Т, если первый аргумент имеет большую длину}

\begin{lstlisting}[language=Lisp]
	(defun longer_then (list1 list2) (> (length list1) (length list2)))
	(longer_then '(1 2 3) '(1 2)) => T
	(longer_then '(1 2) '(1 2 3)) => NIL
	(longer_then Nil '(1)) => NIL
	(longer_then '(1 2) '(1 2)) => NIL
\end{lstlisting}

\section*{6. Каковы результаты вычисления следующих выражений?}

\begin{lstlisting}[language=Lisp]
	(cons 3 (list 5 6)) => (3 5 6)
	(cons 3 '(list 5 6)) => (3 LIST 5 6)
	(list 3 'from 9 'lives (- 9 3)) => (3 FROM 9 LIVES 6)
	(+ (length for 2 too)) (car '(21 22 23))) => The variable FOR is unbound.
	(cdr '(cons is short for ans)) => (IS SHORT FOR ANS)
	(car (list one two))  =>  Undefined variables: ONE TWO
	(car (list 'one 'two)) => ONE
\end{lstlisting}

\clearpage
\section*{7. Дана функция (defun mystery (x) (list (second x) (first x))). Какие результаты вычисления следующих выражений?}

Функции от SECOND до TENTH извлекают соответствующие элементы списка. LAST	возвращает последнюю cons-ячейку в списке (если вызывается с целочисленным аргументом n, возвращает n ячеек).

\begin{lstlisting}[language=Lisp]
	(mystery (one two)) =>  The variable TWO is unbound 
	(mystery (last one two)) => The variable ONE is unbound
	(mystery free) => The variable FREE is unbound
	(mystery one 'two) => The variable ONE is unbound
\end{lstlisting}

Примеры корректной работы:
\begin{lstlisting}[language=Lisp]
	(mystery '(one two)) =>  (TWO ONE)
	(mystery '(last one two)) => (ONE LAST)
	(mystery (last '(one two))) => (NIL TWO)
	(mystery '(free)) => (NIL FREE)
\end{lstlisting}

\section*{8. Написать функцию, которая переводит температуру в системе Фаренгейта температуру по Цельсию (defun f-to-c (temp)…)}

Формулы: c = 5/9*(f-32.0); f = 9/5*c+32.0. Как бы назывался роман Р. Брэдбери "451 по Фаренгейту" в системе по Цельсию?

\begin{lstlisting}[language=Lisp]
	(defun f-to-c (temp) (* (/ 5 9) (- temp 32.0)))
	(f-to-c 451) => 232.77779
	
	(defun c-to-f (temp) (+ (* (/ 9 5) temp) 32.0))
	(c-to-f 232.77779) => 451.0
\end{lstlisting}

Ответ: "232.77779 по Цельсию"



%\clearpage
\section*{9. Что получится при вычисления каждого из выражений?}




 
\begin{lstlisting}[language=Lisp]
	(list 'cons t NIL) =>  (CONS T NIL)
	(eval (list 'cons t NIL)) => (T)
	(eval (eval (list 'cons t NIL))) => The function T is undefined
	(apply #cons "(t NIL)) => illegal complex number format: #CONS
	;(apply #'cons '(t NIL)) => (T)
	(eval NIL) => NIL
	;(eval t) => T
	(list 'eval NIL) => (EVAL NIL) 
	(eval (list 'eval NIL)) => NIL
\end{lstlisting}

\clearpage
\section*{Дополнительно}

1. Написать функцию, вычисляющую катет по заданной гипотенузе и другому катету  прямоугольного треугольника, и составить диаграмму ее вычисления.

\begin{lstlisting}[language=Lisp]
	(defun cathet (hyp another_cathet) (sqrt (- (* hyp hyp) (* another_cathet another_cathet))))
	(cathet 5 4) => 3.0
\end{lstlisting}

\includegraphics[scale=1.2]{img/d1}

\clearpage
2. Написать функцию, вычисляющую площадь трапеции по ее основаниям и высоте, и составить диаграмму ее вычисления.

\begin{lstlisting}[language=Lisp]
	(defun trapezoid_area (a b h) (* 0.5 h (+ a b)))
	(trapezoid_area 2 4 3) => 9.0
\end{lstlisting}

\includegraphics[scale=1.2]{img/d2}

	\bibliographystyle{utf8gost705u}  % стилевой файл для оформления по ГОСТу
	
	\bibliography{51-biblio}          % имя библиографической базы (bib-файла)
	
	
\end{document}
