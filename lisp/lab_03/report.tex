

\documentclass[12pt]{report}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage[14pt]{extsizes}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{amsmath,amsfonts,amssymb,amsthm,mathtools} 
\usepackage{pgfplots}
\usepackage{filecontents}
\usepackage{float}
\usepackage{indentfirst}
\usepackage{eucal}
\usepackage{enumitem}
%s\documentclass[openany]{book}
\frenchspacing

\usepackage{titlesec}
\titleformat{\section}
{\normalsize\bfseries}
{\thesection}
{1em}{}
\titlespacing*{\chapter}{0pt}{-30pt}{8pt}
\titlespacing*{\section}{\parindent}{*4}{*4}
\titlespacing*{\subsection}{\parindent}{*4}{*4}

\usepackage{indentfirst} % Красная строка

\usetikzlibrary{datavisualization}
\usetikzlibrary{datavisualization.formats.functions}

\usepackage{amsmath}

\usepackage{amssymb}

% Для листинга кода:
\lstset{ %
	language=c,                 % выбор языка для подсветки (здесь это С)
	basicstyle=\small\sffamily, % размер и начертание шрифта для подсветки кода
	numbers=left,               % где поставить нумерацию строк (слева\справа)
	numberstyle=\tiny,           % размер шрифта для номеров строк
	stepnumber=1,                   % размер шага между двумя номерами строк
	numbersep=5pt,                % как далеко отстоят номера строк от подсвечиваемого кода
	showspaces=false,            % показывать или нет пробелы специальными отступами
	showstringspaces=false,      % показывать или нет пробелы в строках
	showtabs=false,             % показывать или нет табуляцию в строках
	frame=single,              % рисовать рамку вокруг кода
	tabsize=2,                 % размер табуляции по умолчанию равен 2 пробелам
	captionpos=t,              % позиция заголовка вверху [t] или внизу [b] 
	breaklines=true,           % автоматически переносить строки (да\нет)
	breakatwhitespace=false, % переносить строки только если есть пробел
	escapeinside={\#*}{*)}   % если нужно добавить комментарии в коде
}


\usepackage[left=2cm,right=2cm, top=2cm,bottom=2cm,bindingoffset=0cm]{geometry}
% Для измененных титулов глав:
\usepackage{titlesec, blindtext, color} % подключаем нужные пакеты
\definecolor{gray75}{gray}{0.75} % определяем цвет
\newcommand{\hsp}{\hspace{20pt}} % длина линии в 20pt
% titleformat определяет стиль
\titleformat{\chapter}[hang]{\Huge\bfseries}{\thechapter\hsp\textcolor{gray75}{|}\hsp}{0pt}{\Huge\bfseries}


% plot
\usepackage{pgfplots}
\usepackage{filecontents}
\usetikzlibrary{datavisualization}
\usetikzlibrary{datavisualization.formats.functions}

\begin{document}
	%\def\chaptername{} % убирает "Глава"
	\thispagestyle{empty}
	\begin{titlepage}
		\noindent \begin{minipage}{0.15\textwidth}
			\includegraphics[width=\linewidth]{img/b_logo}
		\end{minipage}
		\noindent\begin{minipage}{0.9\textwidth}\centering
			\textbf{Министерство науки и высшего образования Российской Федерации}\\
			\textbf{Федеральное государственное бюджетное образовательное учреждение высшего образования}\\
			\textbf{~~~«Московский государственный технический университет имени Н.Э.~Баумана}\\
			\textbf{(национальный исследовательский университет)»}\\
			\textbf{(МГТУ им. Н.Э.~Баумана)}
		\end{minipage}
		
		\noindent\rule{18cm}{3pt}
		\newline\newline
		\noindent ФАКУЛЬТЕТ $\underline{\text{«Информатика и системы управления»}}$ \newline\newline
		\noindent КАФЕДРА $\underline{\text{«Программное обеспечение ЭВМ и информационные технологии»}}$\newline\newline\newline\newline\newline
		
		\begin{center}
			\noindent\begin{minipage}{1.1\textwidth}\centering
				\Large\textbf{  Отчет по лабораторной работе №3}\newline
				\textbf{по дисциплине <<Функциональное и логическое}\newline
				\textbf{~~~программирование>>}\newline\newline
			\end{minipage}
		\end{center}
		
		\noindent\textbf{Тема} $\underline{\text{Работа интерпретатора Lisp}}$\newline\newline
		\noindent\textbf{Студент} $\underline{\text{Зайцева А. А.~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}}$\newline\newline
		\noindent\textbf{Группа} $\underline{\text{ИУ7-62Б~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}}$\newline\newline
		\noindent\textbf{Оценка (баллы)} $\underline{\text{~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}}$\newline\newline
		\noindent\textbf{Преподаватели} $\underline{\text{Толпинская Н.Б., Строганов Ю. В.~~~~~~~~~~~~~~~~~~~~~~~~~~~~}}$\newline\newline\newline
		
		\begin{center}
			\vfill
			Москва~---~\the\year
			~г.
		\end{center}
	\end{titlepage}
	
\chapter*{Теоретические вопросы}

\section*{1. Базис Lisp}

Базис -- это минимальный набор инструментов языка и стркутур данных, который позволяет решить любые задачи.


Базис Lisp :

\begin{itemize}
	\item атомы (представляются в памяти пятью указателями  --  name, value, function, property, package) и структуры (представляющиеся бинарными узлами);
	\item базовые (несколько) функций, функционалов и форм: встроенные — примитивные функции (atom, eq, cons, car, cdr); формы (quote, cond, lambda, eval); функционалы (apply, funcall).
\end{itemize}

Атомы:
\begin{itemize} 
	\item символы (идентификаторы) – синтаксически – набор литер (букв и цифр), начинающихся с буквы;
	\item специальные символы – {T, Nil} (используются для обозначения логических констант);
	\item самоопределимые атомы – натуральные числа, дробные числа, вещественные числа, строки – последовательность символов, заключенных в двойные апострофы (например, “abc”);
\end{itemize} 

Более сложные данные – списки и точечные пары (структуры), которые строятся с помощью унифицированных структур – блоков памяти – бинарных узлов.

Определения:

Точечная пара ::= (<атом> . <атом>) | (<атом> . <точечная пара>) | (<точечная пара> . <атом>) | (<точечная пара> . <точечная пара>);

Список ::= <пустой список> | <непустой список>, где 

<пустой список> ::= () | Nil,

<непустой список> ::= (<первый элемент> . <хвост>),

<первый элемент> ::= <S-выражение>,

S-выражение ::= <атом> | <точечная пара>,

<хвост> ::= <список>.


Функцией называется правило, по которому каждому значению одного или нескольких  аргументов ставится в соответствие конкретное значение результата. 

%Функции всюду определены (то есть результат есть всегда), их аргументы и результаты -- S-выражения.

Функционалом, или функцией высшего порядка называется функция, аргументом или  результатом которой является другая функция.

Форма -- функция, которая особым образом обрабатывает свои аргументы, т. е. требует специальной обработки.

%Форма, или вычислимое выражение – это атом или список, который можно  вычислить и получить значение.



\section*{2.Классификация функций}


\begin{enumerate}
	\item Чистые  математические функции (имеют фиксированное количество аргументов, сначала выяисляются все аргументы, а только потом к ним применяется функция);
	\item Рекурсивные функции (основной способ выполнения повторных вычислений);
	\item Специальные функции, или формы (могут принимать произвольное количество аргументов, или аргументы могут обрабатываться по-разному);
	\item Псевдофункции (создают «эффект», например, вывод на экран);
	\item Функции с вариантами значений, из которых выбирается одно;
	\item Функции высших порядков, или функционалы --  функции, аргументом или  результатом которых является другая функция (используются для построения синтаксически управляемых программ);
\end{enumerate}

Классификаци базисных функций и функций ядра.

\begin{enumerate}
	\item Селекторы: car и cdr (будут подробнее расссмотрены ниже).
	\item Конструкторы: cons и list (будут подробнее расссмотрены ниже).
	\item Предикаты -- <<логические>> функции, позволяющие определить структуру элемента:
	\begin{itemize}
		\item atom возвращает T, если значением её единственного аргумента является атом, иначе -- NIL;
		\item null возвращает T, если значение его аргумента -- NIL (пустой список), иначе -- NIL;
		listp возвращает T, если значением её аргумента является список, иначе -- NIL;
		consp возвращает T, если значением её аргумента является структура, представленная в виде списковой ячейки, иначе -- NIL. 
	\end{itemize}
	\item Функции сравнения (принимают два аргумента, перечислены по мере роста <<тщательности>> проверки):
	\begin{itemize}
		\item eq корректно сравнивает два символьных атома. Так как атомы не дублирутюся для данного сеанса работы, то фактически сравниваются соответсвующие указатели. 
		Возвращает T, когда: 1) значением одного из аргументов является атом, и одновременно 2) значения аргументов равны (идентичны). В ином случае значением функции eq является NIL. 
		\item eql корректно сравнивает атомы и числа одинакового типа (синтетической формы записи). Например, (eql 1 1) вернет T, а (eql 1 1.0) -- Nil, так как целое значение 1 и значение с плавающей точкой 1.0 являются представителями различных классов;
		\item = корректно сравнивает только числа, причем числа могут быть разных типов. Например, и (= 1 1), и (= 1 1.0) вернет T;
		\item equal работает идентично eql, но в дополнение умеет корректно сравнивать списки (считая списки эквивалентными, если они рекурсивно, согласно тому же equal, имеют одинаковую структуру и содержимое; считая строки эквивалентными, если они содержат одинаковые знаки);
		\item equalp корректно сравнивает любые S-выражения. 
	\end{itemize}
\end{enumerate}
	


\section*{3. Способы создания функций}

Определение функций пользователя в Lisp-е возможно двумя способами.


\begin{itemize}
	\item Базисный способ  определения  функции - использование $\lambda$-выражения ($\lambda$-нотации). Так создаются функции без имени.
	
	$\lambda$-выражение: (lambda $\lambda$-список форма), 
	где $\lambda$-список --  это формальные параметры функции (список аргументов), а форма -- это тело функции.
	
	Вызов такой функции осуществляется следующим способом: ($\lambda$-выражение последовательность\_форм), 
	где последовательность\_форм -- это фактические параметры.
	
	Вычисление функций без имени может быть также выполнено с использованием функционала apply: (apply $\lambda$-выражение последовательность\_форм), где последовательность\_форм -- это список фактических параметров; или с использованием функционала funcall: (funcall $\lambda$-выражение последовательность\_форм), где последовательность\_форм -- это фактические параметры.
	
	Функционал apply является обычной функцией с двумя  вычисляемыми аргументами, обращение к ней имеет вид: (apply F L), где F – функциональный аргумент и L -- список, рассматриваемый как список фактических параметров для F. Значение функционала -- результат применения F к этим фактическим параметрам.
	
	Функционал funcall – особая функция с вычисляемыми аргументами, обращение к ней: (funcall F e1 … en), n $\geqslant 0$. Её   действие аналогично apply, отличие состоит в том, что аргументы  применяемой функции F задаются не списком, а по отдельности. 
	
	funcall используется тогда, когда во время написания кода количество аргументов известно, apply -- когда неизвестно.
	
	\item Другой способ определения функции -- использование макро-определения defun: 
	
	(defun имя\_функции $\lambda$-выражение), 
	
	или  в облегченной форме:
	
	(defun имя\_функции $(x_1, x_2, ..., x_k)$ форма), 
	где $(x_1, x_2, ..., x_k)$ -- это  список аргументов.
	
	В качестве имени функции выступает символьный атом. 
	Вызов именованной функции осуществляется следующим образом: (имя\_функции последовательность\_форм), 
	где последовательность\_форм -- это фактические параметры.
	Также для ее вызова можно воспользоваться рассмотренными выше функционалами funcall (например, (foo 1 2 3) === (funcall \#'foo 1 2 3)) и apply (например, (apply \#'plot plot-data), где plot-data - список, хранящий аргументы).
	
\end{itemize}

$\lambda$-определение более эффективно, особенно при повторных вычислениях. 

Параметры функции, переданные при вызове, будут связаны с переменными в списке параметров из объявления функции. Еще один способ связывания формальных параметров с фактическими -- использование функции let:

(let ((x1 p1) (x2 p2) ... (xk pk))  e),

где xi -- формальные параметры, pi -- фактические параметры (могут быть формами), e -- форма (что делать).

\section*{4. Работа функций cond, if, and/or}

\textbf{cond}

Общий вид условного выражения:

$(cond \; (p_1  \; e_{11}  \;  e_{12}  \;  …  \;  e_{1m_1})  \;  (p_2  \;  e_{21} \;  e_{22}  \;  …  \;  e_{2m_2})  \;  …  \;  (p_n  \; e_{n1} \;  e_{n2} \;  …  \; e_{nm_n})), m_i \geqslant 0 , n \geqslant 1$

Вычисление условного выражения общего вида выполняется по  следующим правилам:

\begin{enumerate}
	\item последовательно вычисляются условия $p_1, p_2, … p_n$ ветвей выражения до тех пор, пока не встретится выражение $p_i$, значение   которого отлично от NIL;
	\item последовательно вычисляются выражения-формы $e_{i1} \;  e_{i2} \;  … \;  e_{im_i}$ соответствующей ветви, и значение последнего выражения $e_{im_i}$ возвращается в качестве значения функции cond;
	\item если все условия $p_i$ имеют значение NIL, то значением условного выражения становится NIL.
\end{enumerate}

Ветвь условного выражения может иметь вид ($p_i$), когда $m_i$ = 0. Тогда если значение pi $\neq$ NIL, значением условного выражения cond становится значение pi.

В случае, когда pi $\neq$ NIL и $m_i$ $\geqslant$ 2, то есть ветвь cond содержит более  одного выражения $e_i$, эти выражения вычисляются последовательно, и  результатом cond служит значение последнего из них $e_{im_i}$. Таким  образом, в дальнейших вычислениях может быть использовано только значение последнего выражения, и при строго функциональном  программировании случай $m_i$ $\geqslant$ 2 обычно не возникает, т.к. значения  предшествующих $e_{im_i}$ выражений пропадают. 

Использование более одного выражения $e_i$ на ветви cond имеет смысл тогда, когда вычисление предшествующих $e_{im_i}$ выражений даёт побочные эффекты, как при вызове функций ввода и вывода, изменении списка свойств атома, а также определении новой функции с помощью defun. 

К примеру: 

(cond ((< X 5)(print "Значение х меньше пяти") X)
((= X 10)(print "Значение х равно 10") X)
(T(print "Значение х больше пяти, но не 10")X))

Значением этого условного выражения всегда будет значение переменной X, но при этом на печать будет выведена одна из трёх строк, в зависимости от текущего значения X.
 
 
\textbf{if}

Макрофункция (If C E1 E2), встроенная в MuLisp и Common Lisp, вычисляет значение выражения E1, если значение выражения C отлично от NIL, в ином случае она вычисляет значение E2:

(defmacro If (C E1 E2) (list 'cond (list C E1) (list T E2)))

Этот макрос строит и вычисляет условное выражение cond, в котором в качестве условия первой ветви берётся выражение С (первый аргумент If), а выражения E1 и E2 (второй и третий аргумент If) размещаются соответственно на первой и второй ветви cond.

К примеру, для макровызова (If (numberp K) (+ K 10) K) на этапе макрорасширения будет построена конструкция (cond ((numberp K) (+ K 10) (T K)), а на этапе её вычисления в случае K=5 будет получено значение 15.

\textbf{and/or}

К логическим функциям-предикатам относят логическое отрицание not, конъюнкцию and и дизъюнкцию or. Первая из этих функций является обычной, а другие две – особыми, поскольку допускают произвольное количество аргументов, которые не всегда вычисляются. 

Логическое отрицание not вырабатывает соответственно: (not NIL) => T и (not T) => NIL, и может быть определено функцией (defun not (x) (eq x NIL)).

Фактически действие этой функции эквивалентно действию функции null, работающей не только с логическими значениями T и NIL, но и с  произвольными лисповскими выражениями. Поэтому, например: (not '(B ())) => NIL

Тем самым, определение функции not соответствует лисповскому расширенному пониманию логического значения истина. 

Две другие встроенные логические функции также используют расширенное понимание истинного значения. 

Вызов функции and, реализующей конъюнкцию, имеет вид (and e1 e2 … en), n $\geqslant$ 0. 

При вычислении этого функционального обращения последовательно слева направо вычисляются аргументы функции ei – до тех пор, пока не  встретится значение, равное NIL. В этом случае вычисление прерывается и значение функции равно NIL. Если же были вычислены все значения ei и  оказалось, что все они отличны от NIL, то результирующим значением функции and будет значение последнего выражения en .

Вызов функции-дизъюнкции имеет вид (or e1 e2 … en), n $\geqslant$ 0. 

При выполнении вызова последовательно вычисляются аргументы ei (слева направо) – до тех пор, пока не встретится значение ei, отличное от NIL. В этом случае вычисление прерывается и значение функции равно значению этого ei. Если же вычислены значения всех аргументов ei, и оказалось, что они равны NIL, то результирующее значение функции равно NIL.

При n=0 значения функций: (and)=>T, (or)=>NIL.

Таким образом, значение функции and и or не обязательно равно Т или NIL, а может быть произвольным атомом или списочным выражением.

%\section*{Из указаний  к выполнению работы}

%проанализировать эффективность работы разных реализаций.






	
\chapter*{Практические задания}	

\section*{1. Написать функцию, которая принимает целое число и возвращает первое четное число, не меньшее аргумента.}

\begin{lstlisting}[language=Lisp]
	(defun f1 (x) (cond ((= (rem x 2) 1) (+ x 1)) (x)))
	; or shorter
	; (defun f1 (x) (if (oddp x) (+ x 1) x))
	(f1 0) => 0
	(f1 1) => 2
	(f1 -3) => -2
\end{lstlisting}


\section*{2. Написать функцию, которая принимает число и возвращает число того же знака, но с модулем на 1 больше модуля аргумента.}

\begin{lstlisting}[language=Lisp]
	(defun f2 (x) (+ x (cond ((< x 0) -1) (1))))
	; or shorter
	; (defun f2 (x) (+ x (if (< x 0) -1 1)))
	(f2 -5) => -6
	(f2 0.0) => 1.0
	(f2 2/3) => 5/3
\end{lstlisting}


\section*{3. Написать функцию, которая принимает два числа и возвращает список из этих чисел, расположенных по возрастанию.}

\begin{lstlisting}[language=Lisp]
	(defun f3 (x1 x2) (if (> x1 x2) (list x2 x1) (list x1 x2)))
	(f3 -1 2) => (-1 2)
	(f3 3 1) => (1 3)
	(f3 2 2.0) => (2 2.0)
\end{lstlisting}

\section*{4. Написать функцию, которая принимает три числа и возвращает Т только тогда, когда первое число расположено между вторым и третьим.}


\begin{lstlisting}[language=Lisp]
 (defun f4 (x1 x2 x3) (and (< x2 x1) (< x1 x3)))
 (f4 2 1 3) => T
 (f4 1 2 3) => NIL
 (f4 3 1 2) => NIL
 (f4 1 1 2) => NIL
\end{lstlisting}

\section*{8. Решить задачу 4, используя для ее решения конструкции IF, COND, AND/OR.}

(and x y) можно представить как (cond (x y)); (or x y) можно представить как (cond (x) (y)).

Все приведенные ниже функции на тестах из предыдущего номера выдают те же результаты.

\begin{lstlisting}[language=Lisp]
	; cond
	(defun f4_1 (x1  x2 x3) (cond ((< x2 x1) (< x1 x3))))
	; if
	(defun f4_2 (x1  x2 x3) (if (< x2 x1) (< x1 x3)))
	; or 
	(defun f4_3 (x1 x2 x3) (not (or (>= x2 x1) (>= x1 x3))))
\end{lstlisting}

\section*{5. Каков результат вычисления следующих выражений?}

\begin{lstlisting}[language=Lisp]
	(and 'fee 'fie 'foe) => FOE
	(or 'fee 'fie 'foe) => FEE
	(or nil 'fie 'foe) => FIE
	(and nil 'fie 'foe) => NIL
	(and (equal 'abc 'abc) 'yes) => YES
	(or (equal 'abc 'abc) 'yes) => T
\end{lstlisting}

\section*{6. Написать предикат, который принимает два числа-аргумента и возвращает Т, если первое число не меньше второго.}

\begin{lstlisting}[language=Lisp]
	(defun gep (x1 x2) (>= x1 x2))
	;(defun gep (x1 x2) (cond ((>= x1 x2) T)))
	(gep 2 1) => T
	(gep 2 2.0) => T
	(gep -1 2/3) => NIL
\end{lstlisting}


\section*{7. Какой из следующих двух вариантов предиката ошибочен и почему?}

\begin{lstlisting}[language=Lisp]
	(defun pred1 (x) (and (numberp x) (plusp x))) 
	(defun pred2 (x) (and (plusp x) (numberp x)))
\end{lstlisting}

Предикат numberp вырабатывает T, если значение его аргумента – числовой атом, и NIL в противном случае. plusp проверяет, является ли одиночное вещественное число большим чем ноль.

Таким образом, идея приведенных вариантов предиката заключается в том, чтобы проверить, является ли переданный ему аргумент числом, большим нуля.

При вычислении функционального обращения (and e1 e2 … en) последовательно слева направо вычисляются аргументы функции ei – до тех пор, пока не  встретится значение, равное NIL. В этом случае вычисление прерывается и значение функции равно NIL. Если же были вычислены все значения ei и  оказалось, что все они отличны от NIL, то результирующим значением функции and будет значение последнего выражения en.

Таким образом, корректным является первый вариант предиката. Первым будет вычислено значение аргумента e1 = (numberp x), которое проверит, является ли переданный аргумент числовым атомом. Если это не так, то e1 = (numberp x) вернет Nil, на чем вычисление функции and прервется, и результатом всего предиката pred1 будет NIL. Если же переданный аргумент является числовым атомом, то следующим будет вычислено значение аргумента e2 = (plusp x). Это выражение проверит, является ли переданный числовой атом (здесь мы уже уверены, что переданный аргумент -- числовой атом) больше нуля, и станет результатом всего предиката pred1.

Второй вариант же является ошибочным. В нем первым будет вычислено значение аргумента e1 = (plusp x), но plusp принимает только числовой атом, и если x не является числовым атомом, то вычисление всего предиката pred2 завершится с ошибкой "неверный тип".

Примеры вызова pred1 и pred2 (последний вызов pred2 завершается с ошибкой, что и отражает его некорректность):

\begin{lstlisting}[language=Lisp]
	(pred1 1) => T			(pred2 1) => T
	(pred1 0) => NIL		(pred2 0) => NIL
	(pred1 -1) => NIL		(pred2 -1) => NIL
	(pred1 'a) => NIL		(pred2 'a) => The value A is not of type NUMBER
\end{lstlisting}
 
\section*{9. Переписать функцию how-alike, приведенную в лекции и использующую COND, используя только конструкции IF, AND/OR}

Исходная функция:
\begin{lstlisting}[language=Lisp]
(defun how-alike (x y) 
	(cond 
		((or (= x y) (equal x y)) 'the_same) 
		((and (oddp x) (oddp y)) 'both_odd) 
		((and (evenp x) (evenp y)) 'both_even) 
		(t 'diff)
	)
)
(how-alike 1 1) => THE_SAME
(how-alike 2.5 2.5) => THE_SAME
(how-alike -2/3 -4/6) => THE_SAME
(how-alike 3 5) => BOTH_ODD
(how-alike -4 6) => BOTH_EVEN
(how-alike 1 2) => DIFF
\end{lstlisting}

(= работает только с числами, причем они могут быть различных типов; oddp и evenp работают только с целыми числами)

Переписанная функция:
\begin{lstlisting}[language=Lisp]
; if, and, or
(defun how-alike (x y) 
	(if (or (= x y) (equal x y)) 'the_same 
		(if (and (oddp x) (oddp y)) 'both_odd 
			(if (and (evenp x) (evenp y)) 'both_even 
				'diff
			)
		)
	)
)
; and, or
(defun how-alike (x y) 
	(or 
		(and 
			(or (= x y) (equal x y)) 'the_same
		) 
		(and 
			(and (oddp x) (oddp y)) 'both_odd
		) 
		(and 
			(and (evenp x) (evenp y)) 'both_even
		) 
		'diff
	))
	
; if		
(defun how-alike (x y) 
	(if 
		(if (= x y) T (equal x y))
		'the_same
		(if 
			(if (oddp x) (oddp y))
			'both_odd 
			(if 
				(if (evenp x) (evenp y))
				'both_even
				'diff
			)
		)
	)
)
\end{lstlisting}

	\bibliographystyle{utf8gost705u}  % стилевой файл для оформления по ГОСТу
	
	\bibliography{51-biblio}          % имя библиографической базы (bib-файла)
	
	
\end{document}
