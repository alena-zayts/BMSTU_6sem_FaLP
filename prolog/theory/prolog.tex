

\documentclass[12pt]{report}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage[14pt]{extsizes}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{amsmath,amsfonts,amssymb,amsthm,mathtools} 
\usepackage{pgfplots}
\usepackage{filecontents}
\usepackage{float}
\usepackage{indentfirst}
\usepackage{eucal}
\usepackage{enumitem}
%s\documentclass[openany]{book}
\frenchspacing

\usepackage{titlesec}
\titleformat{\section}
{\normalsize\bfseries}
{\thesection}
{1em}{}
\titlespacing*{\chapter}{0pt}{-30pt}{8pt}
\titlespacing*{\section}{\parindent}{*4}{*4}
\titlespacing*{\subsection}{\parindent}{*4}{*4}

\usepackage{indentfirst} % Красная строка

\usetikzlibrary{datavisualization}
\usetikzlibrary{datavisualization.formats.functions}

\usepackage{amsmath}

\usepackage{amssymb}

% Для листинга кода:
\lstset{ %
	language=lisp,                 % выбор языка для подсветки (здесь это С)
	texcl=true,
	extendedchars=\true,
	basicstyle=\small\sffamily, % размер и начертание шрифта для подсветки кода
	numbers=left,               % где поставить нумерацию строк (слева\справа)
	numberstyle=\tiny,           % размер шрифта для номеров строк
	stepnumber=1,                   % размер шага между двумя номерами строк
	numbersep=5pt,                % как далеко отстоят номера строк от подсвечиваемого кода
	showspaces=false,            % показывать или нет пробелы специальными отступами
	showstringspaces=false,      % показывать или нет пробелы в строках
	showtabs=false,             % показывать или нет табуляцию в строках
	frame=single,              % рисовать рамку вокруг кода
	tabsize=2,                 % размер табуляции по умолчанию равен 2 пробелам
	captionpos=t,              % позиция заголовка вверху [t] или внизу [b] 
	breaklines=true,           % автоматически переносить строки (да\нет)
	breakatwhitespace=false, % переносить строки только если есть пробел
	escapeinside={\#*}{*)},  % если нужно добавить комментарии в коде
	%inputencoding=utf8x,
	%extendedchars=\true
}



\usepackage[left=2cm,right=2cm, top=2cm,bottom=2cm,bindingoffset=0cm]{geometry}
% Для измененных титулов глав:
\usepackage{titlesec, blindtext, color} % подключаем нужные пакеты
\definecolor{gray75}{gray}{0.75} % определяем цвет
\newcommand{\hsp}{\hspace{20pt}} % длина линии в 20pt
% titleformat определяет стиль
\titleformat{\chapter}[hang]{\Huge\bfseries}{\thechapter\hsp\textcolor{gray75}{|}\hsp}{0pt}{\Huge\bfseries}


% plot
\usepackage{pgfplots}
\usepackage{filecontents}
\usepackage[unicode, pdftex]{hyperref}
\usetikzlibrary{datavisualization}
\usetikzlibrary{datavisualization.formats.functions}

 
\begin{document}

\chapter*{Теоретическая часть}

\section*{1. Что собой представляет программа на языке пролог?}


\textbf{Программа на Prolog} представляет собой базу знаний и вопрос. 

\begin{itemize}
	\item \textbf{База знаний} состоит из предложений -- фактов и правил, -- используя которые программа выдает ответ на вопрос. Каждое предложение  должно заканчиваться точкой.
	\begin{itemize}
		\item \textbf{Правило} имеет вид: A :- B1, ... , Bn, где A -- заголовок правила (составной терм, который содержит знание); B1, ... , Bn - тело правила (составные термы, которые содержат условия истинности этого знания), символ $":-"$ -- это специальный символ-разделитель.
		\item \textbf{Факт} -- это частный случай правила -- предложение, в котором отсутствует тело (то есть тело пустое).
	\end{itemize}
	\item \textbf{Вопрос} -- это частный случай правила -- предложение, которое состоит только из тела. Используется, чтобы определить, выполняется ли некоторое отношение между описанными в программе объектами. Система рассматривает вопрос как цель, к которой (к истинности которой) надо стремиться. Ответ на вопрос может оказаться логически положительным или отрицательным, в зависимости от того, может ли быть достигнута соответствующая цель.
\end{itemize}

Базис пролога -- матлогика. Используется символьная обработка,  декларативная методология.

\section*{2. Какова структура программы на Prolog?}

Программа на Prolog состоит из следующих разделов, каждый из которых начинается со своего заголовка.

\begin{itemize}
	\item директивы компилятора — зарезервированные символьные константы,
	\item CONSTANTS — раздел описания констант,
	\item DOMAINS — раздел описания доменов,
	\item DATABASE — раздел описания предикатов внутренней базы данных,
	\item PREDICATES — раздел описания предикатов,
	\item CLAUSES — раздел описания предложений базы знаний,
	\item GOAL — раздел описания внутренней цели (вопроса).
\end{itemize}

В программе не обязательно должны быть все разделы.

\section*{3. Как реализуется программа на Prolog? Как формируются результаты работы программы?}

Ответ: Программа на Prolog представляет собой базу знаний и вопрос. База знаний состоит из предложений -- фактов и правил, которые задают истинные знания. Ответ на вопрос может оказаться логически положительным или отрицательным, в зависимости от того, может ли быть достигнута соответствующая цель. 

Вопрос рассматривается системой как цель: найти возможность, исходя из базы знаний, ответить «Да» на поставленный вопрос . Вариантов ответить «Да» на может быть несколько. При поиске ответа рассматриваются альтернативные варианты и находятся все возможные решения (методом проб и ошибок) - множества значений переменных, при которых на поставленный вопрос можно ответить - «Да».


Для выполнения логического вывода используется механизм унификации, встроенный в систему.
Унификация – операция, которая позволяет формализовать процесс логического вывода. С практической точки зрения  - это основной вычислительный шаг, с помощью которого происходят:
\begin{itemize}
	\item двунаправленная передача параметров процедурам,
	\item неразрушающее присваивание,
	\item проверка условий (доказательство).
\end{itemize}

В процессе работы система выполняет большое число унификаций.  Попытка "увидеть одинаковость" – сопоставимость двух термов, может завершаться успехом или тупиковой ситуацией (неудачей). В последнем случае включается механизм отката к предыдущему шагу.

\section*{4. Что такое терм?}

Терм - основной элемент языка Prolog. Терм – это:

\begin{enumerate}
	\item константа (используется для обозначения объекта предметной области): 
	\begin{itemize}
		\item число (целое, вещественное),
		\item cимвольный атом -- комбинация символов латинского алфавита, цифр и ’\_’ (символа подчеркивания), начинающаяся со строчной буквы), используется для обозначения конкретного объекта предметной области или для обозначения конкретного отношения,
		\item строка -- последовательность символов, заключенных в кавычки;
	\end{itemize}
	\item переменная:
	\begin{itemize}
		\item именованная -- комбинация символов латинского алфавита, цифр и ’\_’, начинающаяся с прописной буквы или символа подчеркивания, может связываться с различными объектами (конкретизироваться),
		\item анонимная  - обозначается символом ’\_’, не может быть связана со значением;
	\end{itemize}
	\item составной терм -- средство фиксации информации о том, что между объектами существует определенная связь,  синтаксически представляется так: f(t1, t2, …, tm), где f -  функтор (символьная константа, обозначающая имя отношения между объектами), t1, t2, …, tm – термы (в том  числе  и составные), являющиеся аргументами (арность -- число аргументов).
\end{enumerate}

\section*{5. Что такое предикат в матлогике (математике)?}

Предикат в математической логике -- это (логическая) функция со множеством значений {0, 1} (истина/ложь), определенная на некотором множестве параметров. Предикат называю n-арным, если он определен на n-ой декартовой степени множества М. Таким образом, каждый набор параметров характеризуется либо как «истинный», либо как «ложный».

\section*{6. Что описывает предикат в Prolog?}

Процедура -- совокупность правил, описывающих определенное отношение (заголовки имеют одно и то же имя и одинаковую арность). Предикат -- отношение, определяемое процедурой. Таким образом, предикат в Prolog описывает отношение между аргументами процедуры. 

\section*{7. Назовите виды предложений в программе и приведите примеры таких предложений из вашей программы. Какие предложения являются основными, а какие - не основными? Каковы: синтаксис и семантика (формальный смысл) этих предложений (основных и неосновных)?}

В Prolog есть два типа предложений: 
\begin{itemize}
	\item \textbf{Правило} имеет вид: $A :- B1, ... , Bn$, где A -- заголовок правила (составной терм, который содержит знание); B1, ... , Bn - тело правила (составные термы, которые содержат условия истинности этого знания), символ $":-"$ -- это специальный символ-разделитель;
	\item \textbf{Факт} -- это частный случай правила -- в нем отсутствует тело (то есть тело пустое).
\end{itemize}



TODO 
Примеры из программы:
\begin{itemize}
	\item факт: \emph{car("Mikhail"{}, "Cadillac"{}, "Black"{}, "500000"). }
	\item правило: \emph{car\_by\_phone(Phone, Surname, Model, Cost) :- man(Surame, Phone, \_), car(Name, Model, \_, Cost). }
\end{itemize}



Основными называются предложения, не содержащие переменных. Они предназначены для описания отношений, формирования базы знаний. 

Предложения, содержащие переменные называются неосновными. Они предназначены для поиска ответа в базе знаний.



\section*{8. Каковы назначение, виды и особенности использования переменных в программе на Prolog? Какое предложение БЗ сформулировано в более общей - абстрактной форме: содержащее или не содержащее переменных?}

Переменные предназначены для передачи информации «во времени (за конечное число шагов получить результат) и пространстве (передача значений через параметры)», для повышения уровня абстракции. Они бывают именованными и анонимными. 

Именованная переменная представляет собой комбинацию символов латинского алфавита, цифр и ’\_’, начинающуюся с прописной буквы или символа подчеркивания. В процессе выполнения программы именованные переменные могут связываться с различными объектами – конкретизироваться. Именованная переменная является уникальной в рамках предложения. В разных предложениях может использоваться одно имя переменной для обозначения разных объектов.

Анонимная  переменная обозначается символом ’\_’. Она не может быть связана со значением. Любая анонимная переменная уникальна.



В момент фиксации система не знает, какой объект представляет переменная. Во многих языках последовательность действий при работе с переменными такая: задать значение переменной, а затем работать с самой переменной. В прологе же особый способ работы с переменными -- значение переменной не задается, система сама подбирает такое(-ие) значение(-я), чтобы условие было истинным.

Предложение БЗ, содержащее переменные, сформулировано в более общей форме, так как переменные не имеют значения и могут конкретизироваться различными объектами в ходе работы системы.




TODO??

\section*{9. Что такое подстановка?}

Подстановка - это функция, действующая из множества X переменных в множество T термов программы, (при этом каждой переменной $X_{i} \in  X$ ставится в соответствие терм $t_{i} \in  T$.



Пусть дан терм: $А(X_1, X_2,  \dots ,X_n)$.
Подстановка - множество пар вида: $\{X _ i = t _ i\}$, где $X_i$ –   переменная, а $t_i$ –  терм.


\section*{10. Что такое пример терма? Как и когда строится? Как Вы думаете система строит и хранит термы?}


Пусть $\omega: {X}_{1} = {t}_{1} , {X}_{2} = {t}_{2},… , {X}_{n} = {t}_{n}$ -- подстановка. Тогда результат применения подстановки к терму обозначается $A\omega$. Применение подстановки заключается в замене каждого вхождения переменной $x_i$ на соответствующий терм. Терм B называется примером терма A, если существует такая подстановка $\omega$, что $B = A\omega$.

В процессе выполнения программы система, используя встроенный алгоритм унификации, пытается обосновать возможность истинности вопроса, строя подстановки и примеры термов (вопроса и формулировки знания), используя базу знаний. Построение и подстановки производится путём конкретизации переменных. Сами термы хранятся в стеке.


\chapter*{Лекция 1}
Конъюнкция, дизъюнкция, отрицание  --  базовые функции матлогики. Предикат - логическая функция.

Базис пролога -- матлогика.

Предикат -- логическая функция

Блоки:
База знаний --  clauses.
Запрос разработки -- goal.
Запросы могут быть конъ или дизъ, но нам будут запрещать их использовать

Терм -- константа, переменная или составное тело.

В прологе используется символьная обработка. Декларативная методология. Мы описываем систему знаний из предметной области. Потом задаем вопрос, но хотим получить не только да/нет, но и как (как побочный эффект)? Не запрещено использовать символы. 

Константы -- символьные атомы обозначение объекта/процесса предметной области -- комбинация латинских символов, начинающаяся с маленькой буквы.

А переменная - тоже комбинация символов. Начинается с большой латинской или с нижнего подчеркивания -- именованные переменные. Есть такде анонимные переменные, которые обозначаются одинаково \_

!!!Зачем нужны переменные -- для повышения уровня абстракции

Составные термы - зафиксировать информацию от том, что между какими-то объектами есть связь. f(t1, t2, ..., tn). f - главный функтор -- имя отношения между двумяя объектами, символьный атом (потому что могут быть внутри еще), t- терм.


student(ivanov, mgtu) - константы
student(X, mgtu) -- группа студентов из мгту

student(ivanov, mgtu) и student(ivanov) -- для системы разные запросы.

В момент фиксации система не знает, что такое X


Первые аргуметы считаются как объекты одной природы, вторые - другой. Только мы определям смысл.

Чем больше переменных, тем выше уровень абстракции.

База знаний состоит из фактов (без переменных -- основные, ост - неосн)
Правило
A:-B1,B, ...Bk
A -- заголовок правила (в заголовке формулирубтся знанния о томЮ что..) а тело B всезадает 
Заголовоок - фиксацияя знания о том, чтоо между аргументами мб истинная связь
student(X, mgtu):-докум(X, att), выше(ball, 296)

!!!Особенный сспособ работы с переменными. В ду=ругих языках задаем, потом работаем. Здесь не задаем значение, система сам подбирает значение переменной, чтобы услове былло истинным.  Цель системы -- ответить да

!!!Переменные нужны для передачи данных во времени и пространстве.  Во времени -- через несколько шаги получаем, в пространстве - через параметры, переменные.

запрограммированый метод резолюции позволяет делать поиск ответа на вопрос.

\chapter*{Лекция 2}

что такое декларативно?

в базе знаний нет порядка.

Вопрос тоже мб без переменных -> основные и неосновные (исп переменных -- повышение уровня абрстракции)

Переменные.

Именованные, когда исп, не имеют значение, подбираетсяя. Но в какой момент она какое значение принимает. Методом проб и ошибок. Цель -- подтвердить истинность вопроса с помощью бз. 


Именованные - передача значения во времени и пространстве (для этого в какой-то момент переменная дб конкретизирована каким-то значением. Но это может  быть ошибочным, есть механизм отказа, реконкретизировать переменную). Установление значения длля переменной не связано с понятием типа  (по указателям). Анонимные переменные система не конкретизирует значениями.

Алгоритм унификации - единственный алгоритм доказательства. Многократно запускается (в какой момент?)

про переменные -- ...

Каждое утверждение программы -- ...

<3


Вопросы простые. Пока просто факты.

именованная переменная входит в факты и правила с квантором всеобщности, а в вопрос с квантором существования.

Уникальность: именованная переменная уникальна в рамках одного предложения. Анонимная переменная уникальна всегда.

вообще мы знаем об объектах, набор характеристик.

Заголовок -- составной терм (главный функтор и аргументы в скобочках) -- фиксирует знание о том что между аргументами существует связь, имя которой является главным функтором. Известный объект - символами, неизвестный - переменная.

Заголовок -- правило, тело -- условие.

Факт - чс правила, пустое тело.

В  момент фиксации знания (если еще оно с условием, переменными)  --  условная истина.

\section*{процедрные и декларативные особенности пролога}

Чтобы подобрать знание (которое в заголовке). Чтобы ответить на вопрос, надо подобрать знание --  надо сравнивать вопрос с заголовками. Порядок формально установлен  сверху вниз. Система формально (используя только конструкцию - симв .. и порядок) подбирает знание. И то, и то -- составной терм. Сравнивает по 2  сосавных терма по формальному признаку.

Если есть переменная и в вопросе, и в формулировке знания (а если еще и на одной позиции)




\section*{подстановки и примеры терма}

Без переменных -- основные.

Неосновные термы:

A(X1, ..., Xn), Xi -- переменные.

Подстановкой называется множество пар  вида {xi=ti}, где xi -- переменная, ti  -- терм, не содержащий переменных (ti -- значение для переменной xi).

Чтобы подбирать значения переменных нужно построить подстановвку. Прнято обозначать $teta$


$тета = {X1=t1, ..., Xn=Tn}$ -- применение подстановки к терму


Применение подстановки заключается в замене каждого вхождения переменной Xi на соотвв вхождение ti. Атета

Терм B явл примером терма А, если сущ такая подстановка тета, что 

B=Aтета


Терм С называется общим примером термов А и B, если существуют такие подстановки тета1 и тета2, что С=Атета1 и С = Втета2.


A = plus(1, 2, z)
plus(X, Y, 3)


В первых лабах только факты, потом факты и правила, условие истинности разделено запятыми.

Запрещается использовать сложные вопросы -- один терм.

father(X, Y), father(Y, Z)


Процедура -- группу знаний объединяют в общее знание. Главный функтор у всех одинаковый. Природа объектов одинакова (не про память).

Процедура -- совокупность правил, заголовки которых имеют одинаковые главнаые функторы, одинаковое число аргументов, обозначающих объекты одной природы. 

Это одно знание, которое мб зафиксировано через несколько. Структура знания описывается в разделе предикатов. Не связано с понятием типа или памятью



\section{Простейшие правила логического вывода}

один составной терм

Правила вывода -- утверждения о взаимосвязи между допущениями, которые с позиции исчисления предикатов верны всегда.

4 варианта
факты основные (квантор существования), вопрос основной -- правило-совпадение
факты основные, вопрос неосновной -- правило -- обобщение факта
факты неосновные (квантор всеобщности), вопрос основной -- правило конкретизации факта
факты неосновные, вопрос неосновной --система должна посстроить пример терма-вопроса и терма-знания (подобрать соот подстановки) общий пример строится в 2 шага --- сначала конкретизация правила, а потом правило обобщения.

\section*{унификация терма}

подбор  знания
Назначение -- если сработал, значит для доказательства истинности ответа на вопрос можно использовать знание.

комп по имеративному принципу. опять унификация.


унификация - операция, которая позволяет формализовать процесс логического вывода. Это основной вычислительный шаг, с помощью которого происходит

1. Двунаправленная передачча парамтеров процедурам (знание в неск предложений)
2. Неразрушающее присваивание (конкретизация) 
3. Проверка условий.


Унифицировать (понять, что это знание подходит для доказательства этого вопроса) два терма. Два терма про одно и то же (= -- принудительный (явный) запуск  унификации)

T1=T2


Два терма унификируются по след правилам 

1. Если T1 и T2 -- константы: только если они совпадают
2. Если T1 -- неконкретизированная переменнаяя, а Т2 -- константа или составной терм, не содержащий в качестве аргумента Т1: унификация успешна, а Т1 конкретизируется значением Т2
3. Если Т1 и Т2 -- неконкретизированные (не имеющие значения) переменные: унификация всегда успешна, причем Т1 и Т2 становятсяя сцеплёнными двумя именами (указателями) одного и того же объекта.
Если одна из переменных или оин из тером конкретизивуется значением, то второй моментально тоже конкретизируется им же
4. Если Т1 и Т2 -- составные термы (напр вопрос и заголовок): успешно унифицируются если
а) у Т1 и Т2 одинаковые главные функторы
б) Т1 и Т2 имеют равные арности
в) успещно унифицируется каждая пара их  соотв компонент

\section*{Алгоритм унификации}


\end{document}


