

\documentclass[12pt]{report}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage[14pt]{extsizes}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{amsmath,amsfonts,amssymb,amsthm,mathtools} 
\usepackage{pgfplots}
\usepackage{filecontents}
\usepackage{float}
\usepackage{indentfirst}
\usepackage{eucal}
\usepackage{enumitem}
%s\documentclass[openany]{book}
\frenchspacing

\usepackage{titlesec}
\titleformat{\section}
{\normalsize\bfseries}
{\thesection}
{1em}{}
\titlespacing*{\chapter}{0pt}{-30pt}{8pt}
\titlespacing*{\section}{\parindent}{*4}{*4}
\titlespacing*{\subsection}{\parindent}{*4}{*4}

\usepackage{indentfirst} % Красная строка

\usetikzlibrary{datavisualization}
\usetikzlibrary{datavisualization.formats.functions}

\usepackage{amsmath}

\usepackage{amssymb}

% Для листинга кода:
\lstset{ %
	language=lisp,                 % выбор языка для подсветки (здесь это С)
	texcl=true,
	extendedchars=\true,
	basicstyle=\small\sffamily, % размер и начертание шрифта для подсветки кода
	numbers=left,               % где поставить нумерацию строк (слева\справа)
	numberstyle=\tiny,           % размер шрифта для номеров строк
	stepnumber=1,                   % размер шага между двумя номерами строк
	numbersep=5pt,                % как далеко отстоят номера строк от подсвечиваемого кода
	showspaces=false,            % показывать или нет пробелы специальными отступами
	showstringspaces=false,      % показывать или нет пробелы в строках
	showtabs=false,             % показывать или нет табуляцию в строках
	frame=single,              % рисовать рамку вокруг кода
	tabsize=2,                 % размер табуляции по умолчанию равен 2 пробелам
	captionpos=t,              % позиция заголовка вверху [t] или внизу [b] 
	breaklines=true,           % автоматически переносить строки (да\нет)
	breakatwhitespace=false, % переносить строки только если есть пробел
	escapeinside={\#*}{*)},  % если нужно добавить комментарии в коде
	%inputencoding=utf8x,
	%extendedchars=\true
}



\usepackage[left=2cm,right=2cm, top=2cm,bottom=2cm,bindingoffset=0cm]{geometry}
% Для измененных титулов глав:
\usepackage{titlesec, blindtext, color} % подключаем нужные пакеты
\definecolor{gray75}{gray}{0.75} % определяем цвет
\newcommand{\hsp}{\hspace{20pt}} % длина линии в 20pt
% titleformat определяет стиль
\titleformat{\chapter}[hang]{\Huge\bfseries}{\thechapter\hsp\textcolor{gray75}{|}\hsp}{0pt}{\Huge\bfseries}


% plot
\usepackage{pgfplots}
\usepackage{filecontents}
\usepackage[unicode, pdftex]{hyperref}
\usetikzlibrary{datavisualization}
\usetikzlibrary{datavisualization.formats.functions}

 
\begin{document}

\chapter*{Теоретическая часть}





\section{Общее}
Конъюнкция, дизъюнкция, отрицание  --  базовые функции матлогики. Предикат - логическая функция. Базис пролога -- матлогика.

В прологе используется символьная обработка. Декларативная методология. Мы описываем систему знаний из предметной области. Потом задаем вопрос, но хотим получить не только да/нет, но и как (как побочный эффект)? Не запрещено использовать символы. 


Запросы могут быть конъ или дизъ, но нам будут запрещать их использовать

что такое декларативно? (интернет - Декларативное программирование — это парадигма, при которой описывается желаемый результат, без составления детального алгоритма его получения.)









\section{Терм}

Терм - основной элемент языка Prolog. Терм – это:

\begin{enumerate}
	\item константа --символьный атом (используется для обозначения объекта/процесса предметной области или для обозначения конкретного отношения): 
	\begin{itemize}
		\item число (целое, вещественное),
		\item cимвольный атом -- комбинация символов латинского алфавита, цифр и ’\_’ (символа подчеркивания), начинающаяся со строчной буквы,
		\item строка -- последовательность символов, заключенных в кавычки;
	\end{itemize}
	\item переменная:
	\begin{itemize}
		\item именованная -- комбинация символов латинского алфавита, цифр и ’\_’, начинающаяся с прописной буквы или символа подчеркивания, может связываться с различными объектами (конкретизироваться),
		\item анонимная  - обозначается символом ’\_’, не может быть связана со значением;
	\end{itemize}
	\item составной терм (составное тело) -- средство фиксации информации о том, что между объектами существует определенная связь. Синтаксически представляется так: f(t1, t2, …, tm), где f -  главный (тк внутри мб другие) функтор -- символьная константа, обозначающая имя отношения между объектами; t1, t2, …, tm – термы (в том  числе  и составные), являющиеся аргументами (арность -- число аргументов).
\end{enumerate}



student(ivanov, mgtu) - константы
student(X, mgtu) -- группа студентов из мгту. В момент фиксации система не знает, что такое X
student(ivanov, mgtu) и student(ivanov) -- для системы разные запросы.

Первые аргуметы считаются как объекты одной природы, вторые - другой. Только мы определям смысл.









\section{Переменные}

Зачем нужны переменные -- для повышения уровня абстракции. Чем больше переменных, тем выше уровень абстракции.

Именованная переменная представляет собой комбинацию символов латинского алфавита, цифр и ’\_’, начинающуюся с прописной буквы или символа подчеркивания. В процессе выполнения программы именованные переменные могут связываться с различными объектами – конкретизироваться. Именованная переменная является уникальной в рамках предложения. В разных предложениях может использоваться одно имя переменной для обозначения разных объектов.

Анонимная  переменная обозначается символом ’\_’. Она не может быть связана со значением. Любая анонимная переменная уникальна.

(Уникальность: именованная переменная уникальна в рамках одного предложения. Анонимная переменная уникальна всегда.)

(Именованные) Переменные предназначены для передачи информации «во времени (за конечное число шагов получить результат) и пространстве (передача значений через параметры)». Для этого в какой-то момент переменная дб конкретизирована каким-то значением. Но это может  быть ошибочным, есть механизм отказа (отката), реконкретизировать переменную. В момент фиксации система не знает, какой объект представляет переменная. Во многих языках последовательность действий при работе с переменными такая: задать значение переменной, а затем работать с самой переменной. В прологе же особый способ работы с переменными. Методом проб и ошибок. Цель -- подтвердить истинность вопроса с помощью бз. 

Установление значения длля переменной не связано с понятием типа  (по указателям). 

Анонимные переменные система не конкретизирует значениями.


Именованная переменная входит в факты и правила с квантором всеобщности, а в вопрос с квантором существования.








\section{Что собой представляет программа на языке пролог?}

\textbf{Программа на Prolog} представляет собой базу знаний и вопрос. 

\begin{itemize}
	\item \textbf{База знаний} состоит из предложений -- фактов и правил, -- используя которые программа выдает ответ на вопрос. Каждое предложение  должно заканчиваться точкой.
	\begin{itemize}
		\item \textbf{Правило} имеет вид: A :- B1, ... , Bn, где A -- заголовок правила (составной терм, который содержит знание); B1, ... , Bn - тело правила (составные термы, которые содержат условия истинности этого знания), символ $":-"$ -- это специальный символ-разделитель. Заголовоок - фиксацияя знания о том, что между аргументами мб истинная связь
		\item \textbf{Факт} -- это частный случай правила -- предложение, в котором отсутствует тело (то есть тело пустое).
	\end{itemize}
	\item \textbf{Вопрос} -- это частный случай правила -- предложение, которое состоит только из тела. Используется, чтобы определить, выполняется ли некоторое отношение между описанными в программе объектами. Система рассматривает вопрос как цель, к которой (к истинности которой) надо стремиться. Ответ на вопрос может оказаться логически положительным или отрицательным, в зависимости от того, может ли быть достигнута соответствующая цель.
\end{itemize}

Вопросы и правила (факты) без переменных -- основные (предназначены для описания отношений, формирования базы знаний), с переменными -- неосновные (для поиска ответа в базе знаний)


В базе знаний нет порядка.

В момент фиксации знания (если еще оно с условием, переменными)  --  условная истина.


Алгоритм унификации - единственный алгоритм доказательства. Многократно запускается (в какой момент?)










\section{Структура программы на Prolog}

Программа на Prolog состоит из следующих разделов, каждый из которых начинается со своего заголовка.

\begin{itemize}
	\item директивы компилятора — зарезервированные символьные константы,
	\item CONSTANTS — раздел описания констант,
	\item DOMAINS — раздел описания доменов,
	\item DATABASE — раздел описания предикатов внутренней базы данных,
	\item PREDICATES — раздел описания предикатов,
	\item CLAUSES — раздел описания предложений базы знаний,
	\item GOAL — раздел описания внутренней цели (вопроса).
\end{itemize}

В программе не обязательно должны быть все разделы.























\section{Как реализуется программа на Prolog? Как формируются результаты работы программы?}

Ответ: Программа на Prolog представляет собой базу знаний и вопрос. База знаний состоит из предложений -- фактов и правил, которые задают истинные знания. Ответ на вопрос может оказаться логически положительным или отрицательным, в зависимости от того, может ли быть достигнута соответствующая цель. 

Вопрос рассматривается системой как цель: найти возможность, исходя из базы знаний, ответить «Да» на поставленный вопрос . Вариантов ответить «Да» на может быть несколько. При поиске ответа рассматриваются альтернативные варианты и находятся все возможные решения (методом проб и ошибок) - множества значений переменных, при которых на поставленный вопрос можно ответить - «Да».


Для выполнения логического вывода используется механизм унификации, встроенный в систему.
Унификация – операция, которая позволяет формализовать процесс логического вывода. С практической точки зрения  - это основной вычислительный шаг, с помощью которого происходят:
\begin{itemize}
	\item двунаправленная передача параметров процедурам,
	\item неразрушающее присваивание,
	\item проверка условий (доказательство).
\end{itemize}

В процессе работы система выполняет большое число унификаций.  Попытка "увидеть одинаковость" – сопоставимость двух термов, может завершаться успехом или тупиковой ситуацией (неудачей). В последнем случае включается механизм отката к предыдущему шагу.













\chapter*{Лекция 2}

Алгоритм унификации - единственный алгоритм доказательства. Многократно запускается (в какой момент?)
<3





\section*{процедурные и декларативные особенности пролога}

Чтобы ответить на вопрос, надо подобрать знание, сравивая вопрос с знаниями.  И то, и то -- составной терм. Сравнивает по 2 состсавных терма по формальному признаку. Порядок формально установлен  сверху вниз.

Если есть переменная и в вопросе, и в формулировке знания (а если еще и на одной позиции)





\section{Что такое предикат в матлогике (математике)?}

Предикат в математической логике -- это (логическая) функция со множеством значений {0, 1} (истина/ложь), определенная на некотором множестве параметров. Предикат называю n-арным, если он определен на n-ой декартовой степени множества М. Таким образом, каждый набор параметров характеризуется либо как «истинный», либо как «ложный».


\section{Что описывает предикат в Prolog?}

Процедура -- совокупность правил (описывающих определенное отношение), заголовки которых имеют одинаковые главнаые функторы, одинаковое число аргументов, обозначающих объекты одной природы (не про память). 

Это одно знание, которое мб зафиксировано через несколько. Структура знания описывается в разделе предикатов. 

??Предикат -- отношение, определяемое процедурой. Таким образом, предикат в Prolog описывает отношение между аргументами процедуры. 






\section*{10. Что такое пример терма? Как и когда строится? Как Вы думаете система строит и хранит термы?}


Пусть $\omega: {X}_{1} = {t}_{1} , {X}_{2} = {t}_{2},… , {X}_{n} = {t}_{n}$ -- подстановка. Тогда результат применения подстановки к терму обозначается $A\omega$. 

Применение подстановки заключается в замене каждого вхождения переменной $x_i$ на соответствующий терм. Терм B называется примером терма A, если существует такая подстановка $\omega$, что $B = A\omega$.

В процессе выполнения программы система, используя встроенный алгоритм унификации, пытается обосновать возможность истинности вопроса, строя подстановки и примеры термов (вопроса и формулировки знания), используя базу знаний. Построение и подстановки производится путём конкретизации переменных. Сами термы хранятся в стеке.



\section*{подстановки и примеры терма}

Чтобы подбирать значения переменных нужно построить подстановку. Прнято обозначать $\Theta$

Дан неосновной термы: A(X1, ..., Xn), Xi -- переменные.

Подстановкой называется множество пар  вида {xi=ti}, где xi -- переменная, ti  -- терм, не содержащий переменных (ti -- значение для переменной xi).

Пусть $\Theta = {X}_{1} = {t}_{1} , {X}_{2} = {t}_{2},… , {X}_{n} = {t}_{n}$ -- подстановка. Тогда результат применения подстановки к терму обозначается $A\Theta$. 

Применение подстановки заключается в замене каждого вхождения переменной $x_i$ на соответствующий терм. 

Терм B называется примером терма A, если существует такая подстановка $\Theta$, что $B = A\Theta$.

Терм С называется общим примером термов А и B, если существуют такие подстановки $\Theta_1$ и $\Theta_2$, что $С = A\Theta_1$ и $С = B\Theta_2$.


A = plus(1, 2, z)
plus(X, Y, 3)




??В процессе выполнения программы система, используя встроенный алгоритм унификации, пытается обосновать возможность истинности вопроса, строя подстановки и примеры термов (вопроса и формулировки знания), используя базу знаний. Построение и подстановки производится путём конкретизации переменных. Сами термы хранятся в стеке.






\section{Простейшие правила логического вывода}

один составной терм

Правила вывода -- утверждения о взаимосвязи между допущениями, которые с позиции исчисления предикатов верны всегда.

4 варианта
факты основные (квантор существования), вопрос основной -- правило-совпадение
факты основные, вопрос неосновной -- правило -- обобщение факта
факты неосновные (квантор всеобщности), вопрос основной -- правило конкретизации факта
факты неосновные, вопрос неосновной --система должна посстроить пример терма-вопроса и терма-знания (подобрать соот подстановки) общий пример строится в 2 шага --- сначала конкретизация правила, а потом правило обобщения.

\section*{унификация терма}

подбор  знания
Назначение -- если сработал, значит для доказательства истинности ответа на вопрос можно использовать знание.

комп по имеративному принципу. опять унификация.


унификация - операция, которая позволяет формализовать процесс логического вывода. Это основной вычислительный шаг, с помощью которого происходит

1. Двунаправленная передачча парамтеров процедурам (знание в неск предложений)
2. Неразрушающее присваивание (конкретизация) 
3. Проверка условий.


Унифицировать (понять, что это знание подходит для доказательства этого вопроса) два терма. Два терма про одно и то же (= -- принудительный (явный) запуск  унификации)

T1=T2


Два терма унификируются по след правилам 

1. Если T1 и T2 -- константы: только если они совпадают
2. Если T1 -- неконкретизированная переменнаяя, а Т2 -- константа или составной терм, не содержащий в качестве аргумента Т1: унификация успешна, а Т1 конкретизируется значением Т2
3. Если Т1 и Т2 -- неконкретизированные (не имеющие значения) переменные: унификация всегда успешна, причем Т1 и Т2 становятсяя сцеплёнными двумя именами (указателями) одного и того же объекта.
Если одна из переменных или оин из тером конкретизивуется значением, то второй моментально тоже конкретизируется им же
4. Если Т1 и Т2 -- составные термы (напр вопрос и заголовок): успешно унифицируются если
а) у Т1 и Т2 одинаковые главные функторы
б) Т1 и Т2 имеют равные арности
в) успещно унифицируется каждая пара их  соотв компонент

\section*{Алгоритм унификации}


\end{document}


